{
  "version": 3,
  "sources": ["../src/authRepository.ts"],
  "sourcesContent": ["import axios from 'axios';\nimport * as fs from 'fs';\nimport jsonfile from 'jsonfile';\nimport type * as session from './models/Session';\nimport type { Logger } from './types';\n\n/**\n * Options for authentication.\n */\nexport interface AuthOptions {\n    /**\n     * The client ID for authentication.\n     */\n    clientId: string;\n    /**\n     * The client secret for authentication.\n     */\n    clientSecret: string;\n    /**\n     * Whether to use the authorization code grant flow.\n     */\n    useAuthorizationCodeGrant: boolean;\n    /**\n     * The redirect URI for the authorization code grant flow.\n     */\n    redirectUri: string;\n    /**\n     * The authorization code for the authorization code grant flow.\n     */\n    authCode: string;\n    /**\n     * The file path to store the session.\n     */\n    sessionStoreFilePath: string;\n    /**\n     * The base URL for the API.\n     */\n    baseUrl: string;\n    /**\n     * The scope for the authentication.\n     */\n    scope: string;\n    /**\n     * The timeout for the API requests.\n     */\n    timeout: number;\n    /**\n     * The user agent for the API requests.\n     */\n    userAgent: string;\n    /**\n     * The time before expiry to renew the token.\n     */\n    renewBeforeExpiry: number;\n}\n\ninterface Session extends session.Session {\n    expires_at?: number;\n    authCode?: string;\n}\n\n/**\n * AuthRepository handles the authentication process, including token retrieval and session management.\n */\nexport class AuthRepository {\n    /**\n     * Creates an instance of AuthRepository.\n     *\n     * @param options - The authentication options.\n     * @param log - The logger instance.\n     */\n    constructor(options: AuthOptions, log: Logger) {\n        this.log = log;\n        this.options = options;\n\n        axios.defaults.baseURL = options.baseUrl;\n        axios.defaults.headers.common['user-agent'] = options.userAgent;\n        axios.defaults.timeout = options.timeout;\n\n        if (this.options.useAuthorizationCodeGrant) {\n            this.readSessionFromFile();\n            if (this.hasNewAuthCode()) {\n                this.setEmptySession();\n            }\n        }\n    }\n\n    private log: Logger;\n    private options: AuthOptions;\n    private auth: Session | undefined;\n\n    /**\n     * Retrieves the access token, refreshing it if necessary.\n     *\n     * @returns The access token.\n     * @throws {Error} If unable to retrieve the access token.\n     */\n    async getAccessTokenAsync(): Promise<string> {\n        this.log.debug('Get access token');\n\n        if (!this.hasAccessToken()) {\n            if (this.options.useAuthorizationCodeGrant) {\n                if (this.options.authCode) {\n                    const token = await this.getAuthorizationCodeGrantTokenAsync(this.options.authCode);\n                    await this.setSesssionAsync(token);\n                } else {\n                    this.log.error('You need to get and set a new Auth Code. You can do this in the adapter setting.');\n                    throw new Error('You need to get and set a new Auth Code. You can do this in the adapter setting.');\n                }\n            } else {\n                const token = await this.getClientCredentialsGrantTokenAsync();\n                await this.setSesssionAsync(token);\n            }\n        }\n        if (this.isTokenExpired()) {\n            if (this.options.useAuthorizationCodeGrant) {\n                const token = await this.refreshTokenAsync();\n                await this.setSesssionAsync(token);\n            } else {\n                const token = await this.getClientCredentialsGrantTokenAsync();\n                await this.setSesssionAsync(token);\n            }\n        }\n\n        const accessToken = this.auth?.access_token;\n        if (accessToken) {\n            return accessToken;\n        }\n        throw new Error('No access token!');\n    }\n\n    private async getAuthorizationCodeGrantTokenAsync(authCode: string): Promise<Session> {\n        this.log.debug('Get token via Authorization Code Grant Flow');\n        const data = {\n            grant_type: 'authorization_code',\n            client_id: this.options.clientId,\n            client_secret: this.options.clientSecret,\n            code: authCode,\n            redirect_uri: this.options.redirectUri,\n            scope: this.options.scope,\n        };\n        const session = await this.postTokenRequestAsync(data);\n        this.log.debug(\n            `Token received. Refresh Token received: ${session.refresh_token != undefined}. Access Token expires in: ${session.expires_in}`,\n        );\n        if (!session.refresh_token) {\n            this.log.warn('Receive Access Token without Refresh Token.');\n        }\n        return session;\n    }\n\n    private async getClientCredentialsGrantTokenAsync(): Promise<Session> {\n        this.log.debug('Get token via Client Credentials Grant Flow');\n        const data = {\n            grant_type: 'client_credentials',\n            client_id: this.options.clientId,\n            client_secret: this.options.clientSecret,\n            scope: this.options.scope,\n        };\n        const session = await this.postTokenRequestAsync(data);\n        this.log.debug(\n            `Token received. Refresh Token received: ${session.refresh_token != undefined}. Access Token expires in: ${session.expires_in}`,\n        );\n        return session;\n    }\n\n    private async refreshTokenAsync(): Promise<Session> {\n        if (!this.auth?.refresh_token) {\n            throw new Error('Cannot refresh the token because no refresh token is available.');\n        }\n\n        this.log.debug('Get token via Refresh Token Grant Flow');\n        const data = {\n            grant_type: 'refresh_token',\n            refresh_token: this.auth?.refresh_token,\n            client_id: this.options.clientId,\n            client_secret: this.options.clientSecret,\n        };\n        const session = await this.postTokenRequestAsync(data);\n        this.log.debug(\n            `Token received. Refresh Token received: ${session.refresh_token != undefined}. Access Token expires in: ${session.expires_in}`,\n        );\n        if (!session.refresh_token) {\n            this.log.warn('Receive Access Token without Refresh Token.');\n        }\n        return session;\n    }\n\n    private async postTokenRequestAsync(body: any): Promise<Session> {\n        const stringBody = new URLSearchParams(body).toString();\n        const url = '/oauth/token';\n        try {\n            const { data } = await axios.post<Session>(url, stringBody, {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n            });\n            const expiresIn = data.expires_in ?? 1800;\n            data.expires_at = Date.now() + expiresIn * 1000;\n            //this.log.silly(`TokenData: ${JSON.stringify(data, null, ' ')}`);\n            return data;\n        } catch (error) {\n            throw this.checkError(url, error);\n        }\n    }\n\n    private checkError(suburl: string, error: unknown): unknown {\n        this.log.error(`error from ${suburl}`);\n        this.log.error(JSON.stringify(error, null, ' '));\n        if (axios.isAxiosError(error)) {\n            const axiosError = error as axios.AxiosError;\n            if (axiosError.response != null) {\n                if (axiosError.response.status == 401) {\n                    this.setEmptySession();\n                }\n                if (axiosError.response.data != null) {\n                    const responseText = JSON.stringify(axiosError.response.data, null, ' ');\n                    const errorMessage = `${axiosError.response.statusText}: ${responseText}`;\n                    return new Error(errorMessage);\n                }\n                return new Error(axiosError.response.statusText);\n            }\n        }\n        return error;\n    }\n\n    private readSessionFromFile(): void {\n        if (!this.options.sessionStoreFilePath || !fs.existsSync(this.options.sessionStoreFilePath)) {\n            return;\n        }\n        this.log.debug(`Read session from file '${this.options.sessionStoreFilePath}'`);\n        this.auth = jsonfile.readFileSync(this.options.sessionStoreFilePath, { throws: false });\n    }\n\n    private async setSesssionAsync(auth: Session): Promise<void> {\n        this.log.debug('Set session');\n        if (auth.authCode == null) {\n            auth.authCode = this.options.authCode;\n        }\n        this.auth = auth;\n        if (!this.options.sessionStoreFilePath || !this.options.useAuthorizationCodeGrant) {\n            return;\n        }\n        this.log.debug(`Write session to file '${this.options.sessionStoreFilePath}'`);\n        await jsonfile.writeFile(this.options.sessionStoreFilePath, this.auth, { spaces: 2 });\n    }\n\n    private hasNewAuthCode(): boolean {\n        const hasNewAuthCode = this.auth?.authCode != this.options.authCode;\n        this.log.debug(`Has new auth code: ${hasNewAuthCode}`);\n        return hasNewAuthCode;\n    }\n\n    private setEmptySession(): void {\n        this.log.debug('Set empty session.');\n        this.auth = { authCode: this.options.authCode } as Session;\n    }\n\n    private isTokenExpired(): boolean {\n        const expired = (this.auth?.expires_at || 0) < Date.now() + this.options.renewBeforeExpiry;\n        this.log.debug(`Is token expired: ${expired}`);\n        return expired;\n    }\n\n    private hasAccessToken(): boolean {\n        const hasAccessToken = !!this.auth?.access_token;\n        this.log.debug(`Has access token: ${hasAccessToken}`);\n        return hasAccessToken;\n    }\n}\n"],
  "mappings": "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",
  "names": ["axios", "jsonfile"]
}
